# tree shaking 原理

> Tree-shaking 是指在打包过程中剔除 JavaScript 中未引用的代码（也称为未使用代码），以减小打包后的文件体积，提高应用的性能。

通常，JavaScript 中会存在大量未使用的代码，例如未引用的函数、未被调用的变量等。在传统的打包工具中，这些未使用的代码也会被打包到最终的输出文件中，导致文件体积变大，影响应用的加载和执行速度。Tree-shaking 的目标就是通过静态分析代码的引用关系，将这些未使用的代码从最终的输出文件中剔除掉。

## tree shaking 原理

Tree-shaking 的原理**基于 ES6 模块的静态特性**。

ES6 模块系统具有以下特性，使得 Tree shaking 更加容易和有效：

1. 静态结构： ES6 模块系统的导入和导出语句是静态的，这意味着在编译时可以确定模块之间的依赖关系。因此，打包工具在分析代码时可以准确地识别出未使用的导出，从而进行有效的剪枝。
2. 优化机会： ES6 模块系统具有清晰的导入和导出语法，使得可以很容易地识别出模块之间的依赖关系。这为打包工具提供了优化的机会，可以通过分析这些依赖关系来确定哪些代码是未使用的，并将其从最终的输出中移除。
3. 纯粹性： ES6 模块系统鼓励编写纯粹的函数和模块，即不会在导入模块时执行任何副作用。这使得打包工具可以更加自信地剪切未使用的代码，因为它可以安全地假设未被引用的代码不会对应用程序的行为产生任何影响。

## ES6 module 特点
1. import 导入模块，只能在模块顶层使用
2. import 只能接受字符串常量
3. 模块依赖关系是确定的



## 代码示例

当使用 Webpack 进行打包时，可以通过配置 mode 为 'production'，并启用 optimization 中的 usedExports 来开启 Tree-shaking。

```js
const path = require('path');

module.exports = {
  mode: 'production',
  entry: './index.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'dist'),
  },
  optimization: {
    usedExports: true,
  },
};

```

## 针对 es6 dynamic import 的 Tree shaking 如何实现

1. 静态分析： Webpack 在编译阶段会尝试静态地分析动态 import 语句，以确定导入的模块路径。如果能够确定导入的模块路径是静态的，Webpack 就可以直接将其视为静态 import 处理，进而进行 Tree shaking。
2. 生成异步 Chunk： 当 Webpack 遇到动态 import 语句时，它会将被导入的模块单独打包成一个异步 Chunk。这个异步 Chunk 在运行时才会被加载，因此在编译阶段无法确定其具体内容。
3. Webpack 中的 magic comments： Webpack 提供了一种特殊的注释语法，可以在动态 import 中提供一些提示信息，帮助打包工具更好地进行优化。例如，可以使用 /* webpackIgnore: true */ 来告诉 Webpack 忽略动态 import 语句中的模块，从而防止将其包含在最终的输出中。
4. Webpack 中的预取和预加载： Webpack 还支持通过 import(/* webpackPrefetch: true */ 'module') 和 import(/* webpackPreload: true */ 'module') 来提前加载模块。这些注释可以帮助 Webpack 在编译时确定哪些模块可能会被使用，并据此进行优化和 Tree shaking。
5. SideEffects 标记： 在模块的 package.json 文件中，可以使用 "sideEffects" 字段来告诉 Webpack 模块是否有副作用。如果一个模块被标记为没有副作用，Webpack 在 Tree shaking 时可以更加自信地删除未使用的导出。
6. Scope Hoisting： Webpack 还会尝试对模块进行 Scope Hoisting（作用域提升），将模块合并到一个函数作用域内，以减少模块间的函数调用开销和模块间的闭包嵌套，进而减小输出文件的体积。

