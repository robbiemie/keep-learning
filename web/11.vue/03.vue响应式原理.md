# Vue 响应式原理

> Vue 的响应式原理是 Vue.js 框架的核心之一，它使得当数据发生变化时，相关的视图会自动更新，从而实现了数据和视图的绑定。

![Alt text](image-1.png)

1. 数据劫持（Data Observation）：Vue 2利用Object.defineProperty方法对组件的data对象的每个属性进行劫持。这个方法允许Vue为每个属性设置自定义的getter和setter。当组件访问或修改数据时，通过这些getter和setter，Vue能够进行依赖收集和派发更新。

```js
function defineReactive(obj, key, val) {
  // 递归子属性
  if (typeof val === 'object') {
    observe(val);
  }

  let dep = new Dep();

  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function() {
      Dep.target && dep.addDep(Dep.target);
      return val;
    },
    set: function(newVal) {
      if (val === newVal) return;
      val = newVal;
      // 对新值进行响应式处理
      observe(newVal);
      // 通知依赖更新
      dep.notify();
    }
  });
}

function observe(value) {
  if (typeof value !== 'object') return;
  new Observer(value);
}

class Observer {
  constructor(value) {
    this.value = value;
    this.walk(value);
  }

  walk(obj) {
    Object.keys(obj).forEach(key => defineReactive(obj, key, obj[key]));
  }
}
```

2. 依赖收集（Dependency Collection）：在组件渲染过程中，Vue 会建立虚拟 DOM 和数据之间的联系，当数据被访问时，会收集对应的依赖（Watcher），建立依赖关系图。
  - Watcher：Vue为每个组件实例创建一个或多个观察者（Watcher）实例，用来追踪该组件依赖的所有数据属性。当数据属性被访问时（即触发getter），当前的Watcher会被添加到该属性的依赖列表中（Dep实例）。
  - Dep：每个响应式属性都有一个Dep实例（依赖收集器），用于收集所有依赖于该属性的Watcher。当属性变化时（即触发setter），Dep负责通知所有收集到的Watcher进行更新。

```js
class Dep {
  constructor() {
    this.deps = [];
  }

  addDep(dep) {
    this.deps.push(dep);
  }

  notify() {
    this.deps.forEach(dep => dep.update());
  }
}

// 全局的依赖目标，模拟当前正在计算的Watcher
Dep.target = null;

```

3. 派发更新（Dispatching Update）：当响应式数据发生变化时，通过setter设置的自定义逻辑会被执行。这个过程中，该数据属性对应的Dep实例会通知它收集的所有Watcher实例，告诉它们所依赖的数据已经变化，每个Watcher随后会执行其update方法，导致组件重新渲染或计算属性重新计算。

```js
class Watcher {
  constructor(obj, key, cb) {
    Dep.target = this;
    this.cb = cb;
    this.obj = obj;
    this.key = key;
    this.value = obj[key]; // 触发getter进行依赖收集
    Dep.target = null;
  }

  update() {
    // 数据变化时，执行回调函数
    this.value = this.obj[this.key];
    this.cb(this.value);
  }
}

```
Watcher类用于创建一个观察者对象，用于在依赖项发生变化时重新执行某个特定的函数（如组件的渲染函数）。

4. 虚拟DOM（Virtual DOM）：Vue的响应式系统和虚拟DOM紧密结合。当数据变化导致组件需要更新时，Vue首先会生成新的虚拟DOM树，然后与旧的虚拟DOM树进行比较（diff算法），计算出需要在真实DOM上进行的最小更改集合，并执行这些DOM更新。
5. 数组的响应式处理：由于JavaScript的限制，Vue无法直接通过索引设置数组项或修改数组的长度来触发更新。Vue 2通过劫持数组的变异方法（如push、pop、splice等）来解决这个问题。当这些方法被调用时，Vue可以手动触发视图更新。
6. Vue限制: 新增或删除对象属性
  - Vue 2无法自动检测对象属性的添加或删除。为了解决这个问题，Vue提供了Vue.set和Vue.delete方法。
  - 直接修改数组索引：由于Vue 2无法检测到通过索引直接设置数组项，推荐使用变异方法或Vue.set。


## 源码示例

```js
function defineReactive(obj, key, val) {
    // 递归子属性
    if (typeof val === 'object') {
        observe(val);
    }

    // 为每个属性创建依赖对象
    const dep = new Dep();

    Object.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        get: function reactiveGetter() {
            // 收集依赖
            if (Dep.target) {
                dep.addDep(Dep.target);
            }
            return val;
        },
        set: function reactiveSetter(newVal) {
            if (newVal === val) return;
            val = newVal;
            // 触发依赖更新
            dep.notify();
        }
    });
}

function observe(value) {
    if (typeof value !== 'object') return;
    new Observer(value);
}

class Observer {
    constructor(value) {
        this.value = value;

        if (Array.isArray(value)) {
            // 处理数组
            // 略过，实际上Vue会针对数组方法进行重写以便能够侦测到数组的变动
        } else {
            this.walk(value);
        }
    }

    walk(obj) {
        const keys = Object.keys(obj);
        for (let i = 0; i < keys.length; i++) {
            defineReactive(obj, keys[i], obj[keys[i]]);
        }
    }
}

class Dep {
    constructor() {
        this.subscribers = [];
    }

    addDep(sub) {
        this.subscribers.push(sub);
    }

    notify() {
        this.subscribers.forEach(sub => {
            sub.update();
        });
    }
}

// 模拟Watcher
Dep.target = null;

function setTarget(target) {
    Dep.target = target;
}

// 使用示例
const data = { price: 5, quantity: 2 };
observe(data);

setTarget({
    update: function() {
        console.log(`Total price: ${data.price * data.quantity}`);
    }
});

// 触发响应
data.price = 10;

```