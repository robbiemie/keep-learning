# vue3 响应式原理

> Vue 3 的响应式系统是基于 ES6 的 Proxy 特性重新实现的，与 Vue 2 基于 Object.defineProperty 的实现相比，它提供了更好的性能和更灵活的响应性追踪能力。

这种新的实现方式允许 Vue 3 直接监听对象和数组的变化，而无需预先定义 getter 和 setter，从而实现了更为自然和高效的数据响应式变化侦测。

## 流程图

```
用户操作或数据变化
      |
      v
响应式对象属性被读/写
      |
      +-----------------+
      |                 |
      |  使用 Proxy     | <--- 创建响应式对象时封装原始对象
      |  拦截操作       |
      |                 |
      +-----------------+
      |                 |
读操作 <--- 依赖收集（track） ----> 收集当前执行的effect
      |                 |
      +-----------------+
      |                 |
写操作 <--- 触发变更（trigger）--> 执行依赖的effect
      |                 |
      +-----------------+
            |
            v
         更新DOM

```

## 响应式系统工作原理

1. 响应式对象的创建：当你使用 reactive 或 ref 函数创建一个响应式对象时，Vue 通过 Proxy 将原始对象包裹起来。这个代理对象可以拦截对原始对象的访问和修改操作。
2. 依赖收集（Track）：当响应式对象的属性被读取时，如在渲染函数或计算属性中，Vue 会记录（track）这个属性和当前执行的“effect”（比如渲染函数）之间的依赖关系。
3. 变更通知（Trigger）：当响应式对象的属性被修改时，Vue 通过代理拦截这个修改操作，并触发（trigger）依赖于这个属性的所有“effect”重新执行，以响应这个变化。
4. 更新 DOM：重新执行的“effect”会导致组件重新渲染，Vue 的渲染引擎会计算出需要更新的最小DOM范围，并应用这些变更。

这个过程确保了当响应式数据变化时，依赖于这些数据的视图和其他计算能够自动更新。

## 源码实现

相关概念

- reactive：一个函数，用于创建一个响应式对象。
- ref：一个函数，用于创建一个响应式的引用值。
- effect：用于包装一个函数，这个函数的任何响应式状态的读取都会被跟踪，当状态变化时重新执行。
- track 和 trigger：内部函数，用于依赖收集和变更通知。

### 响应式对象创建（reactive）

reactive 函数是通过 Proxy 创建响应式对象的入口。下面是一个简化的 reactive 实现：

```js
function reactive(target) {
    if (typeof target !== 'object') return target;

    const handler = {
        get(target, key, receiver) {
            // 依赖收集
            track(target, key);
            return Reflect.get(target, key, receiver);
        },
        set(target, key, value, receiver) {
            const result = Reflect.set(target, key, value, receiver);
            // 触发更新
            trigger(target, key);
            return result;
        }
    };

    return new Proxy(target, handler);
}
```

### 依赖收集（track）和变更通知（trigger）

track 和 trigger 函数是响应式系统中依赖收集和变更通知的核心。

```js
let activeEffect = null;

function track(target, key) {
    if (activeEffect) {
        // 这里省略了依赖收集的具体实现细节
    }
}

function trigger(target, key) {
    // 这里省略了查找和执行依赖效果的具体实现细节
}
```

### effect 函数

effect 函数用于创建一个副作用，它会执行传入的函数，并自动跟踪其依赖。

```js
function effect(fn) {
    const effectFn = () => {
        activeEffect = effectFn;
        fn();
        activeEffect = null;
    };

    effectFn();
    return effectFn;
}
```

这个函数在执行 fn 时，将 activeEffect 设置为当前的 effect 函数。这样，当 fn 中读取响应式数据时，track 函数就可以关联当前的 effect 与读取的属性。


## 核心概念

### 使用 Proxy 实现响应式

> Vue 3 的响应式系统利用 Proxy 来拦截对象的读取和写入操作。

Proxy 是 ES6 引入的一种新特性，允许创建一个对象的代理，从而可以拦截并自定义对象的基本操作，如属性读取、属性赋值、枚举属性等。

当使用 reactive 函数（或 ref 对于基本类型）创建一个响应式对象时，Vue 3 会返回这个对象的 Proxy 代理。这个代理能够拦截对对象的所有操作，Vue 通过这种方式来追踪依赖和触发更新。

### 追踪变化和依赖收集

当组件在渲染过程中访问响应式对象的属性时，Vue 3 的响应式系统会自动追踪这些属性的访问，并将当前的渲染函数或计算属性作为依赖收集起来。这是通过 Proxy 的 get 操作拦截实现的。

当响应式对象的属性发生变化时（通过 set 操作拦截），Vue 会通知所有依赖于这个属性的侧面重新计算或组件重新渲染，从而更新视图。

### 响应式 API

Vue 3 提供了几个核心的响应式 API，主要包括：

- reactive(obj): 接收一个普通对象并返回该对象的响应式代理，用于创建复杂类型（如对象或数组）的响应式数据。
- ref(value): 用于创建一个响应式的数据引用，ref 可以包裹一个基本类型值或对象，使其变得响应式。通过 .value 属性访问或修改它的值。
- computed(fn): 接收一个 getter 函数，并基于其返回值返回一个不可变的响应式引用。该引用只会在依赖项改变时重新计算。
- watch(source, callback): 用于观察响应式数据的变化，当数据变化时执行回调函数。

### 优势

使用 Proxy 实现响应式带来了几个优势：

- 更好的性能和内存利用：因为不需要为每个属性创建 getter 和 setter，减少了初始化时的开销。
- 更灵活的侦测能力：Proxy 能够拦截包括属性添加、属性删除、数组索引设置等更多类型的操作。
- 更简洁的实现：Proxy 提供了一种更直接和统一的方法来拦截对象操作，简化了响应式系统的内部实现。

### 弊端

尽管 Vue 3 的响应式系统在许多方面都有所改进，它仍然有一些限制和潜在的缺陷，主要包括：

1. Proxy 兼容性
  - 浏览器兼容性：Proxy 是 ES6 的一个特性，不支持 IE11 或更早版本的浏览器。对于需要支持旧浏览器的项目，这可能是一个限制。Vue 3 响应式系统的这一设计选择意味着它不能在不使用 Polyfill 的情况下直接在这些旧浏览器上运行。
2. 性能考量
  - 大规模对象：虽然 Proxy 性能对于绝大多数应用场景都是足够的，但在处理非常大的对象或深层嵌套对象时，可能会遇到性能瓶颈。尽管 Vue 3 的性能已经得到了显著提升，但在极端情况下，响应式系统的开销仍然需要考虑。
3. 响应式转换限制
  - 手动转换：Vue 3 不会自动将所有对象转换为响应式对象。例如，通过 ref 或 reactive 创建的响应式对象，如果被赋予一个新的普通对象，这个新对象不会自动转换为响应式的。这可能导致一些细微的 bug，特别是对于新接触 Vue 3 的开发者来说。
4. 第三方类库兼容性
  - 外部类库的集成：在某些情况下，将 Vue 3 的响应式系统与没有专门为响应式编程设计的第三方库一起使用可能会遇到问题。这些库可能不会触发 Vue 的响应式更新，或者可能需要额外的封装或适配器来确保它们能够正常工作。
5. 响应式侦测的边界
  - 原生对象变动侦测：Vue 3 的响应式系统无法侦测到使用原生方法直接修改数组长度（如 arr.length = 0）或直接通过索引设置数组项（如 arr[0] = 'newItem'）的变化。虽然这在日常开发中较少遇到，但在某些特定场景下可能会引起注意。
